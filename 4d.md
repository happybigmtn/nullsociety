# Guided 3D Scene Replacement Plan (Feature Branch)

## Executive Summary

This document outlines a comprehensive plan to replicate the physics, simulation, and user experience of Evolution Gaming's First Person series while maintaining our distinct on-chain identity. Evolution's First Person games serve as the gold standard for RNG casino experiencesâ€”they use physics engines to create authentic-feeling outcomes while the actual results are determined by RNG. Our approach mirrors this: **the blockchain is the single source of truth; the 3D layer is a deterministic visual replay that looks chaotic but must converge to the chain-provided outcome.**

## Strategic Context: Why Replicate Evolution?

Evolution's First Person series solves three critical friction points:

1. **Intimidation Reduction**: Live tables can be daunting for novices. First Person games allow asynchronous playâ€”the game waits for the player.
2. **Pacing Preferences**: Experienced players can enjoy rapid-fire rounds via "Fast Play" capabilities.
3. **Connectivity Resilience**: 3D rendered games are less bandwidth-demanding than live video streams.

Our blockchain-verified outcomes add a fourth advantage: **provable fairness** that Evolution cannot offer.

---

## Scope

- Casino games only (no non-casino 3D work).
- Keep existing 2D mode in all games; 3D is optional and toggleable.

### Core Games (Phase 1-2)

- **Baccarat** - VIP hall aesthetic, squeeze mechanic
- **Roulette** - Physics-based ball, Lightning variant
- **Craps** - Mechanical arm, speakeasy theme
- **Blackjack** - Multi-hand, side bets
- **Casino War (Dragon Tiger)** - Fast play, outcome lighting
- **Sic Bo** - Triple dice with guided physics

### Card Game Extensions (Phase 2-3)

- **Three Card Poker** - Simple poker variant
- **Casino Hold'em** - Texas Hold'em vs house
- **HiLo** - Higher/lower prediction
- **Video Poker** - Machine-style single player

### Game Shows (Phase 3+)

- **Football Studio** - Dragon Tiger with sports theme
- **Mega Ball** - Lottery drum with 51 balls
- **Dream Catcher** - Vertical money wheel
- **Lightning Roulette** - Roulette with multipliers
- **Crazy Time** - Complex wheel + bonus games (future)

## Goal

Replace all casino 3D scenes from scratch with guided physics and high-fidelity rendering that always resolves to the chain-provided final state. The experience should be so immersive that players "forget that this is not a live game" while maintaining absolute consistency with the provably fair on-chain outcome.

---

## Chain Final State Contract (CRITICAL - AUTHORITATIVE SOURCE)

**The blockchain is the ONLY source of truth for game outcomes. The 3D engine must NEVER compute outcomesâ€”it only dramatizes chain-delivered results.**

### How Outcomes Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Blockchain     â”‚â”€â”€â”€â”€â–¶â”‚  Chain Service  â”‚â”€â”€â”€â”€â–¶â”‚  3D Engine      â”‚
â”‚  (RNG Source)   â”‚     â”‚  (Decoder)      â”‚     â”‚  (Visualizer)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
    Outcome                   Event               Animation
    decided                  parsed              resolves to
    on-chain               for round             chain outcome
```

### Chain Events and State Sources

- Chain events decoded in `website/src/services/CasinoChainService.ts`
- Game state snapshots parsed in `website/src/hooks/useTerminalGame.ts`

### Round ID and Outcome Derivation (Per Game)

| Game                 | Round ID Source            | Outcome Source                                |
| -------------------- | -------------------------- | --------------------------------------------- |
| **Roulette**         | `rouletteHistory.length`   | Last `rouletteHistory` value (winning number) |
| **Craps**            | `crapsRollHistory.length`  | `dice[0..1]` from chain state                 |
| **Sic Bo**           | `sicBoHistory.length`      | `dice[0..2]` from chain state                 |
| **Blackjack**        | `sessionId + moveNumber`   | `playerCards/dealerCards + stage`             |
| **Baccarat**         | `sessionId + moveNumber`   | `playerCards/bankerCards`                     |
| **War/Dragon Tiger** | `warHistory.length`        | `playerCard, dealerCard`                      |
| **Three Card Poker** | `threeCardHistory.length`  | `playerHand[0..2], dealerHand[0..2]`          |
| **Casino Hold'em**   | `sessionId + moveNumber`   | `communityCards, playerHand, dealerHand`      |
| **HiLo**             | `hiloHistory.length`       | `currentCard, nextCard, direction`            |
| **Video Poker**      | `videoPokerHistory.length` | `dealtHand[0..4], finalHand[0..4], heldCards` |

### Implementation Note

`moveNumber` is not currently stored in UI state. Options:

- Add `moveNumber` to `GameState`, or
- Use a fallback (`sessionId + history.length`) until chain exposes move count.

### The Cardinal Rule

```typescript
// WRONG - Never do this
const outcome = calculateDiceRoll(seed);

// RIGHT - Always from chain
const outcome = chainState.crapsRollHistory[roundId];
```

---

## Branch Setup (Clean-Slate 3D)

1. Create branch: `feature/guided-3d-scenes`
2. Delete all existing 3D code under `website/src/components/casino/3d/` (entire folder)
3. Important ordering: add new stub exports and update imports in `website/src/components/casino/games/*` in the same change so the app still builds after deletion
4. Remove old 3D exports (`website/src/components/casino/3d/index.ts`) and re-export from new 3D folder
5. Keep 2D fallback UI in all games so app runs while we rebuild 3D
6. Add placeholder wrappers that render 2D until each new 3D scene is implemented

---

## Dependencies and State Architecture

- Zustand is not in `website/package.json` today. Options:
  - Add Zustand for the transient 60 FPS store, or
  - Use `useSyncExternalStore` to avoid a new dependency
- Preserve existing 3D toggle preferences via localStorage migration

---

## New 3D Architecture (From Scratch)

### Folder Layout

```
website/src/components/casino/3d/
â”œâ”€â”€ engine/
â”‚   â”œâ”€â”€ GuidedStore.ts        # Zustand transient updates (60 FPS without React re-renders)
â”‚   â”œâ”€â”€ GuidedRound.ts        # Round state types and phase management
â”‚   â””â”€â”€ timeStep.ts           # Fixed timestep helpers for determinism
â”œâ”€â”€ physics/
â”‚   â”œâ”€â”€ guidedForces.ts       # Attractors, velocity gates, noise modulation
â”‚   â”œâ”€â”€ noise.ts              # Seeded Perlin/Simplex for organic randomness
â”‚   â””â”€â”€ colliders.ts          # Factory helpers for collider shapes
â”œâ”€â”€ scenes/
â”‚   â”œâ”€â”€ roulette/
â”‚   â”œâ”€â”€ craps/
â”‚   â”œâ”€â”€ sicbo/
â”‚   â”œâ”€â”€ blackjack/
â”‚   â”œâ”€â”€ baccarat/
â”‚   â”œâ”€â”€ cardTable/           # Shared card table base
â”‚   â”œâ”€â”€ war/                 # Dragon Tiger
â”‚   â”œâ”€â”€ threeCardPoker/      # Three Card Poker
â”‚   â”œâ”€â”€ casinoHoldem/        # Casino Hold'em / Ultimate Texas Hold'em
â”‚   â”œâ”€â”€ hilo/                # HiLo card game
â”‚   â”œâ”€â”€ videoPoker/          # Video Poker machine
â”‚   â”œâ”€â”€ megaBall/            # Mega Ball lottery
â”‚   â””â”€â”€ moneyWheel/          # Dream Catcher / Money Wheel
â”œâ”€â”€ materials/
â”‚   â””â”€â”€ MaterialConfig.ts     # PBR materials and shared shader chunks
â”œâ”€â”€ shaders/
â”‚   â”œâ”€â”€ LightningShader.ts    # Lightning Roulette effect
â”‚   â””â”€â”€ SqueezeShader.ts      # Baccarat card squeeze
â”œâ”€â”€ post/
â”‚   â””â”€â”€ CasinoPostProcessing.tsx  # Bloom, tone mapping, effects
â””â”€â”€ audio/
    â”œâ”€â”€ AudioManager.ts       # Singleton audio context manager
    â”œâ”€â”€ CollisionSound.tsx    # Physics-driven impact sounds
    â””â”€â”€ AmbientSoundscape.tsx # Background casino atmosphere
```

### Core Data Types

```typescript
interface GuidedRound<T> {
  roundId: string; // Derived from chain state
  seed: number; // Deterministic random from roundId
  phase: "idle" | "launch" | "decay" | "settle" | "reveal";
  outcome: T | null; // Chain result (null until arrived)
  outcomeAtMs: number | null; // When chain result arrived
  startedAtMs: number;
  pendingOutcome?: T; // If outcome arrives during animation
}
```

---

## Deterministic Physics + Chaotic Visuals

### Physics Engine Configuration (Rapier)

```typescript
const PHYSICS_CONFIG = {
  timeStep: 1 / 60, // Fixed 60 Hz for determinism
  updateLoop: "independent",
  maxCcdSubsteps: 4, // Prevent tunneling
  numSolverIterations: 8, // Stable collisions
};
```

### Deterministic Randomness

Use a seeded PRNG (Mulberry32) per roundId for all initial conditions:

- Launch impulse vectors
- Spin directions and speeds
- Noise offsets for attractor forces

This ensures **every client simulating the same round sees identical physics**.

### Guided Physics Algorithm

The key insight from Evolution's games: let physics run freely during the exciting part, then subtly guide to the outcome when objects slow down.

```
1. LAUNCH: Apply vigorous, random-looking impulse (seeded)
   - No guidanceâ€”pure physics chaos
   - Players see authentic bouncing/spinning

2. DECAY: Natural deceleration via friction and collisions
   - Still no guidance
   - If chain outcome hasn't arrived, continue free simulation

3. SETTLE: Once velocity < threshold AND outcome known
   - Activate subtle attractor forces toward target
   - Gate by velocity (fast objects never guided)
   - Gate by position (e.g., ball must be below rim)
   - Add noise to force direction to avoid "magnetic" appearance
   - Clamp force magnitude to prevent teleportation

4. REVEAL: Object at rest matching chain outcome
   - Highlight result
   - Hand off to UI for payouts
```

### Attractor Force Formula

```typescript
// Only active when velocity < velocityGate and phase === 'settle'
force = normalize(target - pos) * baseStrength * falloff * (0.6 + 0.4 * noise);
force = clamp(force, maxForce);
```

### Minimum Animation Time

If chain outcome arrives instantly, we still show a satisfying animation (3-4 seconds for dice, 5-7 seconds for roulette) before guidance kicks in.

---

## Rendering Pipeline

### PBR Materials

Evolution's games achieve their quality through realistic materials:

| Surface       | Roughness | Metalness | Notes               |
| ------------- | --------- | --------- | ------------------- |
| Felt          | 0.95      | 0.02      | High friction look  |
| Chrome        | 0.08      | 1.0       | Wheel parts         |
| Polished Wood | 0.35      | 0.15      | Table rails         |
| Cards         | 0.45      | 0.1       | Slight sheen        |
| Dice          | 0.28      | 0.18      | Casino dice finish  |
| Chip          | 0.40      | 0.20      | Ceramic casino chip |

### 3D Chip Stacking System

Evolution's games render chip stacks in 3D on betting layouts. We replicate this for authenticity:

```typescript
// ChipStackManager.ts
export interface ChipDenomination {
  value: number;
  color: string;
  model: string; // GLTF reference
}

export const CHIP_DENOMINATIONS: ChipDenomination[] = [
  { value: 1, color: "#ffffff", model: "chip_white.glb" },
  { value: 5, color: "#ff0000", model: "chip_red.glb" },
  { value: 25, color: "#00ff00", model: "chip_green.glb" },
  { value: 100, color: "#000000", model: "chip_black.glb" },
  { value: 500, color: "#9933ff", model: "chip_purple.glb" },
];

export function calculateChipStack(amount: number): ChipDenomination[] {
  // Greedy algorithm: largest denominations first
  const stack: ChipDenomination[] = [];
  let remaining = amount;
  for (const denom of [...CHIP_DENOMINATIONS].reverse()) {
    while (remaining >= denom.value) {
      stack.push(denom);
      remaining -= denom.value;
    }
  }
  return stack;
}
```

**Visual Implementation**:

- Chips stack with slight random rotation (Â±5Â°) for realism
- Stack height = chip count Ã— chip thickness (0.003m)
- Instanced rendering for performance (all chips share geometry)
- On bet placement: chips animate from tray to betting spot
- On win: chips animate from center to player tray with stagger

### Environment and Lighting

- HDR environment maps via `PMREMGenerator` + `RoomEnvironment`
- `ACESFilmicToneMapping` for realistic camera look
- Per-scene exposure tuning

### Post-Processing

- **Bloom**: For lightning effects, win highlights (threshold > 1.0 emissive)
- **Depth of Field**: Optional for dramatic close-ups
- **Motion Blur**: Subtle during fast spins (disabled at settle)

---

## Scene-by-Scene Implementation

### Roulette + Lightning Roulette

**Evolution Reference**: First Person Roulette features "realistically animated ball spins" with the ball circling the track multiple times before dropping.

#### Physics Model

| Element    | Collider Type        | Restitution | Notes                     |
| ---------- | -------------------- | ----------- | ------------------------- |
| Bowl       | Mesh (complex slope) | 0.3         | Ball rolls on track       |
| Rotor      | Kinematic            | N/A         | Constant angular velocity |
| Deflectors | Small convex         | 0.8         | "Mushrooms" for chaos     |
| Frets      | Thin cuboids         | 0.4         | Pocket dividers           |
| Ball       | Sphere               | 0.85        | Steel-like elasticity     |

#### Guided Settling

1. Ball launched tangentially opposite rotor spin
2. Free collision with deflectors and rim during decay
3. Attractor activates when `velocity < 3.0 m/s` AND `ball.y < rimHeight`
4. Compute target pocket position for chain's winning number
5. Synchronize wheel rotation so pocket aligns with ball landing

#### Lightning Roulette Variant

- Chain provides 1-5 lucky numbers + multipliers per round
- GLSL shader on betting grid with `uLightningActive`, `uTime`, `uTargetNumbers`
- Emissive values > 1.0 to trigger bloom
- Lightning strike effect before spin starts

#### Camera Behavior

- Auto-orbit tracking ball during launch
- Dolly in during settle phase for suspense
- Allow user toggle between dynamic and classic static camera

---

### Craps (First Person Craps)

**Evolution Reference**: First Person Craps uses a "luxurious speakeasy-style virtual studio" with a mechanical dice shooter arm. The soundscape "instills that sense of being in a brick-and-mortar casino."

#### Environment: 1920s Speakeasy

- Warm amber lighting (incandescent simulation)
- Rich wood textures (mahogany/oak)
- Art deco details, brass fixtures
- Ambient audio: muffled crowd, subtle jazz, glass clinking
- Low contrast, moody atmosphere

#### Mechanical Shooter Arm

Evolution uses a robotic arm in both Live and First Person Craps to ensure fairness. We replicate this:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 CRAPS TABLE                      â”‚
â”‚                                                  â”‚
â”‚  [PYRAMID WALL]                                 â”‚
â”‚                                                  â”‚
â”‚         â—â—                                      â”‚
â”‚         dice                                    â”‚
â”‚                                                  â”‚
â”‚                              â•”â•â•â•â•—              â”‚
â”‚                              â•‘ARMâ•‘â—„â”€â”€ Mechanicalâ”‚
â”‚                              â•šâ•â•â•â•    Shooter   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- Arm picks up dice from holder
- Animated swing with seeded release angle/force variation
- Dice spawn as physics objects at moment of release
- Ensures dice always hit back wall (casino rule)

#### Dice Physics

| Parameter       | Value | Notes                    |
| --------------- | ----- | ------------------------ |
| Mass            | 4.5g  | Standard 16mm casino die |
| Restitution     | 0.3   | Moderate bounce          |
| Static Friction | 0.25  | Felt grip                |
| Angular Damping | 0.5   | Tumble decay             |

#### Back Wall Pyramid Collider

The rubber pyramid backing is essential for randomization:

- Model as mesh collider with pyramid geometry
- Higher restitution (0.6) than felt
- Creates chaotic scatter when dice hit

#### Guidance to Chain Outcome

1. Wait until BOTH dice velocity < 4.5 m/s
2. Identify target face-up values from chain `dice[0..1]`
3. Apply subtle torque to flip any incorrect faces
4. Stop guiding as soon as a die matches its target
5. Never guide dice that might collide with each other

#### UX Features (Evolution-Inspired)

**Easy Mode**: Toggle to simplify betting layout

- Hide complex prop bets (Horn, Hardways, etc.)
- Show only Pass/Don't Pass, Field, Big 6/8
- Helps new players avoid paralysis

**My Numbers Panel**: Personalized payout display

- List each dice total (2-12)
- Highlight totals where player has bets
- Show potential payout in currency
- Allow quick bet placement by clicking numbers

**Interactive Tutorial**: Step-by-step guide

- Tooltips on hover explaining each bet
- Guided first-play sequence
- Points out outcome on dice after roll

---

### Sic Bo

- Triple dice physics with guided settle
- Transparent dome shaker (visual only, no physics)
- Triangle settle layout with per-round offsets
- Avoid dice stacking via curved bowl bottom

---

### Blackjack (First Person Blackjack)

**Evolution Reference**: First Person Blackjack offers up to 5 hands per player, side bets (Perfect Pairs, 21+3), and a "Deal Now" button for fast play.

#### Table Setup

- Half-round table with 5-7 seat positions
- Shoe, discard tray, chip rack for authenticity
- "Gold" theme: dark wood, green/blue felt
- Spotlight on active player area

#### Card System

**Object Pool**: 20-24 card meshes, recycled between deals

**Texture Atlas**: Single 4096x4096 atlas (13 ranks Ã— 4 suits)

```typescript
// UV calculation for card face
col = RANKS.indexOf(rank); // 0-12
row = SUITS.indexOf(suit); // 0-3
offset = new Vector2(col / 13, 1 - (row + 1) / 4);
```

**Deal Animation**: Cubic Bezier path

- Duration: ~500-600ms per card
- Arc height above table for "loft"
- Ease-out deceleration on landing
- Cards dealt face-up or face-down per game rules

**Dealer Peek**: 15-degree corner lift for blackjack check

#### Multi-Hand Support

- Camera widens FOV for multiple active hands
- Dolly to active hand when decisions needed

#### Side Bet Visual Representation

Evolution's First Person Blackjack includes Perfect Pairs and 21+3 side bets with visual feedback:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                BLACKJACK TABLE                   â”‚
â”‚                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚21+3  â”‚  â”‚ PP   â”‚  â”‚21+3  â”‚  â”‚ PP   â”‚ â—„â”€ Side â”‚
â”‚  â”‚ â—‹    â”‚  â”‚ â—‹    â”‚  â”‚ â—‹    â”‚  â”‚ â—‹    â”‚    Bets â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  MAIN   â”‚  â”‚  MAIN   â”‚  â”‚  MAIN   â”‚ â—„â”€ Main  â”‚
â”‚  â”‚   â—‹     â”‚  â”‚   â—‹     â”‚  â”‚   â—‹     â”‚    Bets  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Side Bet Types**:

- **Perfect Pairs (PP)**: Pays on player's first two cards forming a pair
- **21+3**: Pays on player's first two + dealer's upcard forming poker hands

**Visual Effects**:

- Side bet circles glow on win (gold for Perfect Pairs, green for 21+3)
- Winning combination cards briefly highlight
- Chip stacks on side bet spots use smaller chips

#### Speed Control

- "Deal Now" button for immediate start after betting
- No artificial delaysâ€”player controls pace
- Immediate response to Hit/Stand/etc.

---

### Baccarat (First Person Baccarat)

**Evolution Reference**: First Person Baccarat offers 12 tables (6 regular, 6 no-commission), shuffle on demand, deal free hands, and squeeze mechanics.

#### VIP Hall Aesthetic

- Grand hall environment with multiple visible tables
- Marble floors, ornate decor
- Calm, luxurious lighting
- Premium material finishes

#### Multi-Table System

Evolution's 12-table hall allows:

- Sort tables by streaks/road patterns
- Quick table switching
- Multi-table betting view

**Table Sorting UI** (Evolution feature):

```typescript
interface BaccaratTableSummary {
  tableId: string;
  currentStreak: { side: "banker" | "player"; length: number };
  lastResults: ("B" | "P" | "T")[]; // Last 10 outcomes
  bigRoadPattern: string; // Encoded pattern for sorting
  activePlayers: number;
}

// Sort options for table list
type TableSortOption =
  | "banker_streak_desc" // Longest Banker streak first
  | "player_streak_desc" // Longest Player streak first
  | "any_streak_desc" // Any streak (longest first)
  | "alternating" // Tables with choppy patterns
  | "recent_tie"; // Tables with recent Tie outcomes
```

**Visual Indicators**:

- ğŸ”µ Blue badge for Banker streak (e.g., "BÃ—5")
- ğŸ”´ Red badge for Player streak (e.g., "PÃ—3")
- Animated glow on "hot" tables (streak â‰¥ 5)

Implementation approach:

- Start with single table
- Design for expansion to multi-table UI
- Chain must track separate "table" states (or simulate via separate shoe seeds)

#### Card Squeeze Mechanic

Baccarat players enjoy the ritual of slowly revealing cards:

```glsl
// Squeeze vertex shader
uniform float uBendStrength;  // 0.0 to 1.0 (user drag)
uniform float uRevealThreshold;

void main() {
  float bendAmount = uv.y * uv.y;  // Non-linear bend
  float bendAngle = uBendStrength * bendAmount * 1.5708;  // Max 90Â°
  // ... vertex displacement
}
```

- User drags to "peel" card corner
- Gradual reveal via bend + mask transition
- Optional "Fast Play" mode skips squeeze

#### Roadmap Display

- Big Road, Bead Plate, Cockroach Pig rendered via CanvasTexture
- Embedded in table or as digital sign in scene
- Real-time update after each hand

#### Player Control Features

**Shuffle Shoe on Demand**:

- "Shuffle" button available between rounds
- Triggers chain to reset deck order (reinitialize PRNG)
- Visual shuffle animation (riffle effect)
- Players feel control over "cold" shoes

**Deal Free Hands**:

- Advance game with no bet placed
- Cards dealt, roadmaps updated, no win/loss
- Allows trend-building for superstitious players
- Chain must support zero-bet rounds (or client simulation with clear disclaimer)

#### Red Envelope Bonus (If Supported)

- Shift ambient light to warm red
- Boost point lights for celebration
- Hanging lanterns glow on trigger

---

### War / Dragon Tiger

**Evolution Reference**: First Person Dragon Tiger features dramatic lightingâ€”Dragon and Tiger statues that light up on wins, with synchronized color shifts.

#### Gameplay

- Two cards dealt: Dragon spot, Tiger spot
- High card wins (ranks only)
- Tie is a separate bet
- Extremely fast rounds (player-controlled pace)

#### Visual Theme

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                  â”‚
â”‚    ğŸ‰ DRAGON          ğŸ¯ TIGER                  â”‚
â”‚    (Red glow)         (Gold glow)               â”‚
â”‚                                                  â”‚
â”‚      â”Œâ”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”                   â”‚
â”‚      â”‚CARDâ”‚            â”‚CARDâ”‚                   â”‚
â”‚      â””â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                  â”‚
â”‚    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•             â”‚
â”‚         LED strips / accent lighting            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Outcome-Driven Lighting

- **Dragon wins**: Red wash, dragon statue pulses red
- **Tiger wins**: Gold/blue wash, tiger statue pulses gold
- Lighting manager controls all via shader uniforms
- Synchronized with result reveal for Pavlovian impact

#### Speed as Feature

- Deal + reveal in <1 second
- Players can spam rounds rapidly
- Chain must handle high-frequency calls

#### Trend Display

- Dragon/Tiger bead plate (like Baccarat)
- Streak history prominently shown

---

### Three Card Poker

A popular poker variant where players compete against the dealer with 3-card hands. Simple mechanics make it ideal for fast 3D implementation.

#### Gameplay

- Player places Ante bet, receives 3 cards face-down
- Player decides: Fold (lose ante) or Play (place equal Play bet)
- Dealer reveals; best poker hand wins
- Optional side bets: Pair Plus (pays on player's hand only)

#### 3D Scene Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              THREE CARD POKER                    â”‚
â”‚                                                  â”‚
â”‚              â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”                   â”‚
â”‚   DEALER     â”‚ ?? â”‚ ?? â”‚ ?? â”‚                   â”‚
â”‚              â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚            BETTING AREA                   â”‚   â”‚
â”‚  â”‚   â—‹ Ante    â—‹ Play    â—‹ Pair+            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                  â”‚
â”‚              â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”                   â”‚
â”‚   PLAYER     â”‚ Aâ™  â”‚ Kâ™  â”‚ Qâ™  â”‚                   â”‚
â”‚              â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Physics & Animation

- **No complex physics** - cards only, no dice/ball
- Reuse `CardPoolManager` from Blackjack
- Deal animation: 3 cards to dealer (face-down), 3 to player (face-up)
- Reveal animation: dealer cards flip with stagger (150ms each)

#### Chain Integration

```typescript
interface ThreeCardPokerOutcome {
  playerHand: [Card, Card, Card];
  dealerHand: [Card, Card, Card];
  playerHandRank: PokerHandRank; // High Card, Pair, Flush, Straight, etc.
  dealerHandRank: PokerHandRank;
  winner: "player" | "dealer" | "push";
  qualifies: boolean; // Dealer needs Queen-high to qualify
}
```

#### Visual Polish

- Winning hand cards glow gold
- "DEALER DOESN'T QUALIFY" text effect when dealer < Q-high
- Pair Plus wins trigger independent celebration (player can win Pair+ but lose main)

---

### Casino Hold'em / Ultimate Texas Hold'em

Texas Hold'em poker variant against the house. More complex than Three Card Poker with community cards and multiple betting rounds.

#### Gameplay Phases

1. **Ante**: Player posts Ante + optional AA side bet
2. **Deal**: 2 hole cards to player, 2 to dealer (face-down)
3. **Flop Decision**: 3 community cards; player can bet 2x Ante or check
4. **Turn/River**: 2 more community; player can bet 1x Ante or fold
5. **Showdown**: Best 5-card hand wins

#### 3D Scene Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            CASINO HOLD'EM                        â”‚
â”‚                                                  â”‚
â”‚   DEALER    â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”                         â”‚
â”‚             â”‚ ?? â”‚ ?? â”‚                         â”‚
â”‚             â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜                         â”‚
â”‚                                                  â”‚
â”‚   BOARD     â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”         â”‚
â”‚             â”‚ Aâ™¥ â”‚ Kâ™¦ â”‚ 7â™  â”‚    â”‚    â”‚         â”‚
â”‚             â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜         â”‚
â”‚                                                  â”‚
â”‚   PLAYER    â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”                         â”‚
â”‚             â”‚ Aâ™  â”‚ Qâ™  â”‚                         â”‚
â”‚             â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜                         â”‚
â”‚                                                  â”‚
â”‚   â—‹ Ante   â—‹ Call/2x   â—‹ Call/1x   â—‹ AA        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Animation Sequence

1. Deal hole cards (player face-up, dealer face-down)
2. Wait for player Bet/Check decision
3. Deal flop (3 cards with stagger)
4. Wait for player Bet/Check decision
5. Deal turn + river
6. Reveal dealer hole cards
7. Highlight winning 5-card combination

#### Chain Integration

```typescript
interface CasinoHoldemOutcome {
  playerHoleCards: [Card, Card];
  dealerHoleCards: [Card, Card];
  communityCards: [Card, Card, Card, Card, Card];
  playerBestHand: Card[]; // Best 5 from 7
  dealerBestHand: Card[];
  winner: "player" | "dealer" | "push";
  aaBonus?: { rank: string; payout: number }; // Side bet result
}
```

#### Special Effects

- Community card reveal: subtle "thump" camera shake
- Winning hand highlight: trace line connecting the 5 winning cards
- AA Bonus win: golden particle burst

---

### HiLo (Card Game)

Ultra-simple prediction game: will the next card be higher or lower?

#### Gameplay

1. A card is shown face-up
2. Player bets Higher, Lower, or Same (optional high-risk)
3. Next card reveals; correct prediction wins

#### 3D Scene

Minimal setupâ€”single card pedestal with dramatic lighting:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    HILO                          â”‚
â”‚                                                  â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚              â”‚            â”‚                     â”‚
â”‚              â”‚    7â™£      â”‚  â—„â”€ Current Card    â”‚
â”‚              â”‚            â”‚                     â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                                                  â”‚
â”‚         [HIGHER]  [SAME]  [LOWER]               â”‚
â”‚                                                  â”‚
â”‚              Next card: ???                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Animation

- Current card slides off-screen left
- New card slides in from right (or flips from deck)
- On correct: green pulse + ascending sound
- On incorrect: red pulse + descending sound
- Streak counter with escalating visual effects

#### Chain Integration

```typescript
interface HiLoOutcome {
  currentCard: Card;
  nextCard: Card;
  comparison: "higher" | "lower" | "same";
}
```

#### Gamification Elements

- **Streak Multiplier**: Consecutive correct guesses increase payout
- **Risk Ladder**: Visual ladder showing potential winnings if player continues
- **Cash Out**: Player can take winnings or risk for higher multiplier

---

### Video Poker

Classic video poker machine simulationâ€”single player, no dealer interaction.

#### Gameplay

1. Player bets (1-5 coins per hand)
2. 5 cards dealt
3. Player selects cards to hold (0-5)
4. Held cards stay; others replaced
5. Final hand evaluated against paytable

#### 3D Scene: Machine Cabinet

Unlike table games, Video Poker is a **machine interface**. Two approaches:

**Option A: Full 3D Cabinet**

- Render a video poker machine model
- Screen shows cards on texture
- Buttons are 3D clickable elements

**Option B: Hybrid 2D/3D**

- 3D card meshes on flat surface
- 2D UI for buttons (simpler, faster)

Recommended: **Option B** for initial implementation.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              VIDEO POKER                         â”‚
â”‚   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•      â”‚
â”‚   â”‚ JACKS OR BETTER                        â”‚     â”‚
â”‚   â”‚                                        â”‚     â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”  â”‚     â”‚
â”‚   â”‚  â”‚ Jâ™  â”‚ â”‚ Qâ™¥ â”‚ â”‚ 7â™¦ â”‚ â”‚ 7â™£ â”‚ â”‚ Aâ™  â”‚  â”‚     â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚   â”‚  [HOLD] [    ] [HOLD] [HOLD] [    ]  â”‚     â”‚
â”‚   â”‚                                        â”‚     â”‚
â”‚   â”‚  [BET 1] [BET MAX]       [DRAW/DEAL]  â”‚     â”‚
â”‚   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•      â”‚
â”‚                                                  â”‚
â”‚   Credits: 100      Bet: 5      Win: 0          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Animationg

- **Deal**: Cards fly in from right with stagger
- **Hold Toggle**: Card bounces up slightly when held
- **Draw**: Non-held cards flip to back, slide out, new cards slide in
- **Win**: Winning cards pulse, credit counter animates upward

#### Chain Integration

```typescript
interface VideoPokerOutcome {
  initialHand: [Card, Card, Card, Card, Card];
  heldPositions: boolean[]; // Player's choice (client-side)
  finalHand: [Card, Card, Card, Card, Card];
  handRank: VideoPokerHand; // Royal Flush, Four of a Kind, etc.
  payout: number;
}

type VideoPokerHand =
  | "royal_flush" // 250x (or 4000x on max bet)
  | "straight_flush" // 50x
  | "four_of_a_kind" // 25x
  | "full_house" // 9x
  | "flush" // 6x
  | "straight" // 4x
  | "three_of_a_kind" // 3x
  | "two_pair" // 2x
  | "jacks_or_better" // 1x
  | "nothing"; // 0x
```

#### Paytable Variants

Support multiple paytable schemas:

- Jacks or Better (standard)
- Deuces Wild (2s are wild)
- Bonus Poker (higher 4-of-a-kind payouts)
- Double Bonus Poker

---

## UX + State Orchestration

### Animation Blocking

- Preserve `onAnimationBlockingChange` callback
- Suppress win effects and bet UI during animation
- Only show results after reveal phase

### Skip Animation

- Button appears after 1-2 seconds of animation
- On skip: fast-forward to final positions
- Chain outcome unchanged (already determined)

### 3D/2D Toggle

- Only allow toggle between rounds
- Remember preference in localStorage
- Auto-disable 3D on low FPS with prompt

### "Go Live" Bridge (Future)

Evolution's signature feature: portal animation transitioning to live dealer.

If implemented:

- `LivePortal` component with WebGL/WebRTC cross-fade
- Pre-buffer video stream on hover
- Camera dolly into portal before opacity transition

---

## Audio Design

**Evolution Reference**: First Person Craps' soundscape "instills that sense of being in a brick-and-mortar casino."

### Positional Audio

- Attach sounds to 3D objects (dice, ball, cards)
- Volume scales with distance
- Panning follows camera position

### Collision-Based Sounds

| Event              | Sound         | Volume Scale |
| ------------------ | ------------- | ------------ |
| Dice hit felt      | Soft thud     | Velocity     |
| Dice hit wall      | Sharp clack   | Velocity     |
| Ball on track      | Rolling loop  | Speed        |
| Ball hit deflector | Metallic ping | Velocity     |
| Card dealt         | Slide + snap  | Fixed        |
| Chip stack         | Ceramic click | Fixed        |

### Ambient Soundscape

- Muffled crowd murmur (density varies by theme)
- Speakeasy: subtle jazz, glass clinking
- Casino floor: slot machine distant sounds
- VIP: minimal, calm

### Audio Profiles

| Profile   | Crowd Density | Notes             |
| --------- | ------------- | ----------------- |
| Speakeasy | 0.3           | Intimate, quiet   |
| Vegas     | 0.8           | Busy casino floor |
| VIP       | 0.15          | Minimal lounge    |

---

## Performance Targets

| Metric               | Target      |
| -------------------- | ----------- |
| Frame Rate (Desktop) | 60 FPS      |
| Frame Rate (Mobile)  | 30+ FPS     |
| Physics Step         | Fixed 1/60s |
| GC Pauses            | < 1ms       |
| Texture Memory       | ~10MB       |
| Audio Latency        | < 20ms      |
| First Paint          | < 2s        |

### Optimization Strategies

- Draco compression for GLTF geometry
- Basis/WebP textures
- Object pooling for cards/chips
- Auto-disable bloom on mobile
- LOD for complex geometry
- Pre-allocated work vectors (avoid allocation in hot loops)

### Web Worker for Physics (Heavy Scenes)

For computationally intensive scenes (Mega Ball with 51 balls, Sic Bo with 3 dice), consider offloading physics to a Web Worker:

```typescript
// PhysicsWorker.ts
self.onmessage = (e: MessageEvent<PhysicsCommand>) => {
  switch (e.data.type) {
    case "step":
      world.step();
      const transforms = extractBodyTransforms(world);
      self.postMessage({ type: "transforms", data: transforms });
      break;
    case "applyForce":
      const body = world.getRigidBody(e.data.bodyHandle);
      body.applyImpulse(e.data.impulse, true);
      break;
  }
};
```

**Trade-offs**:

- âœ… Keeps main thread free for rendering
- âœ… Can run physics at higher frequency (120Hz)
- âš ï¸ Adds complexity for synchronization
- âš ï¸ Transfer overhead for transform data

**Recommendation**: Use Web Worker for Mega Ball; keep main thread for simpler games.

---

## Testing and Validation

### Deterministic Replay Harness

- Feed recorded chain outcomes into 3D engine
- Same seed â†’ identical animation
- Verify across browsers (watch for floating-point variance)

### Visual QA Checklist

| Game         | Check                                          |
| ------------ | ---------------------------------------------- |
| Roulette     | Ball rattles before settling; no fret clipping |
| Craps        | Dice hit back wall; no instant face snaps      |
| Blackjack    | Cards follow 600ms rhythm with loft            |
| Baccarat     | Squeeze reveals correct card; roadmaps update  |
| Dragon Tiger | Lights sync with winner; handles rapid play    |

### Edge Cases

- Very late chain outcome arrival
- Very early outcome (instant RNG)
- Dice stacking or cocking
- Ball bouncing out of wheel
- Maximum animation timeout

---

## Rollout Plan

### Phase 1: Infrastructure + Core Physics

**Goal**: Establish foundation for all games

- Zustand store + transient updates (GuidedStore)
- Guided forces system (attractors, velocity gates)
- Deterministic RNG (Mulberry32 seeded PRNG)
- Material presets (PBR configs)
- Card pool manager + texture atlas
- Chip stack system (instanced rendering)

### Phase 2: Physics-Based Games

**Goal**: Complete all physics-heavy games

| Game     | Key Features                                  |
| -------- | --------------------------------------------- |
| Roulette | Wheel physics, ball settling, pocket guidance |
| Craps    | Mechanical arm, pyramid wall, dual dice       |
| Sic Bo   | Triple dice, dome shaker visual               |

### Phase 3: Core Card Games

**Goal**: Complete primary card-based games

| Game         | Key Features                                  |
| ------------ | --------------------------------------------- |
| Blackjack    | Multi-hand, side bets (PP, 21+3), dealer peek |
| Dragon Tiger | Outcome lighting, fast play, trend display    |
| Baccarat     | Squeeze shader, roadmaps, shuffle on demand   |

### Phase 4: Card Game Extensions

**Goal**: Add poker variants and simple games

| Game             | Key Features                               |
| ---------------- | ------------------------------------------ |
| Three Card Poker | 3-card hands, Pair Plus side bet           |
| Casino Hold'em   | Community cards, AA bonus                  |
| HiLo             | Higher/lower prediction, streak multiplier |
| Video Poker      | Hold/draw mechanic, paytable variants      |

### Phase 5: Audio + Effects + Polish

**Goal**: Production-quality presentation

- Collision-based sounds (physics-driven)
- Ambient soundscapes (speakeasy/vegas/vip profiles)
- Post-processing pipeline (bloom, tone mapping)
- Lightning shader for Roulette variant
- Web Worker for physics offload (prep for Mega Ball)

### Phase 6: Initial Release

**Goal**: Ship core games to production

- Feature flag rollout (3D toggle per game)
- Performance monitoring (FPS, GC pauses)
- User feedback collection
- A/B test 3D vs 2D engagement

### Phase 7: Game Shows (Post-Release)

**Goal**: Add high-production-value game shows

| Game               | Key Features                                        |
| ------------------ | --------------------------------------------------- |
| Lightning Roulette | Lucky numbers, multiplier lightning effects         |
| Football Studio    | Sports theme, LED boards, live score integration    |
| Dream Catcher      | Vertical wheel, flapper physics, multiplier re-spin |

### Phase 8: Mega Ball + Future

**Goal**: Most complex physics simulation

| Game       | Key Features                                   |
| ---------- | ---------------------------------------------- |
| Mega Ball  | 51-ball drum, Web Worker physics, bingo cards  |
| Crazy Time | Main wheel + 4 bonus mini-games (very complex) |

---

## Future Expansion (Game Shows)

The following game show formats extend beyond traditional table games. They require unique physics systems and visual treatments but share the same chain-authoritative outcome philosophy.

---

### Football Studio (Top Card)

A Dragon Tiger variant themed around football (soccer), with Home vs Away replacing Dragon vs Tiger.

#### Gameplay

- Identical to Dragon Tiger: two cards dealt, high card wins
- Bet on Home, Away, or Draw
- Optional live sports data integration

#### 3D Scene

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             FOOTBALL STUDIO                      â”‚
â”‚                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   HOME      â”‚           â”‚    AWAY     â”‚      â”‚
â”‚  â”‚   ğŸ”µâš½      â”‚    VS     â”‚    ğŸ”´âš½      â”‚      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”    â”‚           â”‚    â”Œâ”€â”€â”€â”€â”   â”‚      â”‚
â”‚  â”‚  â”‚ Kâ™  â”‚    â”‚           â”‚    â”‚ Qâ™¥ â”‚   â”‚      â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”˜    â”‚           â”‚    â””â”€â”€â”€â”€â”˜   â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                  â”‚
â”‚           Live: MAN UTD 2 - 1 CHELSEA           â”‚
â”‚                   72'                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Visual Theme

- Table surface: grass pitch texture with white lines
- LED boards around edge showing live scores
- Stadium ambience: crowd chanting, whistle sounds
- Home/Away sides color-coded (team colors configurable)

#### Chain Integration

```typescript
interface FootballStudioOutcome {
  homeCard: Card;
  awayCard: Card;
  winner: "home" | "away" | "draw";
}
```

#### Sports Data Integration (Optional)

- External API feed for live match scores
- Displayed on LED board texture (CanvasTexture updates)
- No gameplay impactâ€”purely atmospheric

---

### Mega Ball

Lottery-style game with 51 balls in a tumbling drum. The most physics-intensive game in the portfolio.

#### Gameplay

1. Player purchases bingo-style cards (5Ã—5 grid with random numbers 1-51)
2. 20 balls drawn from drum
3. Final ball has a random multiplier (5x, 10x, 25x, 50x, 100x)
4. Payouts based on lines completed Ã— multiplier

#### 3D Scene

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  MEGA BALL                       â”‚
â”‚                                                  â”‚
â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚      â”‚ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹   â”‚  â—„â”€ Drum   â”‚
â”‚      â”‚  â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹    â”‚    tumbling â”‚
â”‚      â”‚   â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹ â—‹     â”‚             â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                    â†“                             â”‚
â”‚               Draw Tube                          â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚              â”‚  42  â”‚  â—„â”€ Selected ball          â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                                                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  Bingo Card:  1  12  23  34  45         â”‚   â”‚
â”‚   â”‚               2  13  24  35  46         â”‚   â”‚
â”‚   â”‚               ...                        â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Physics Implementation

**Challenge**: 51 balls is computationally expensive.

**Solution: Hybrid Physics**

```typescript
const MEGA_BALL_PHYSICS = {
  ballCount: 51,
  ballRadius: 0.04, // meters
  ballMass: 0.02, // kg
  drumRadius: 1.2,
  drumRotationSpeed: 2.0, // rad/s
  airJetForce: 8.0, // Newtons (simulates blower)
  drawTubeSuctionForce: 15.0,
};
```

**Optimization Strategy**:

1. Use Web Worker for physics (see Performance section)
2. LOD: balls far from camera use lower poly spheres
3. Instanced rendering for all balls
4. Only enable full collision for balls near tube

**Guided Ball Selection**:

- When chain specifies drawn ball (e.g., ball #42), apply attractor to that ball toward tube entrance
- Other balls experience repulsion from tube area
- Ball rises up tube and displays at top

#### Chain Integration

```typescript
interface MegaBallOutcome {
  drawnNumbers: number[]; // 20 numbers (1-51)
  megaBallNumber: number; // Final ball with multiplier
  megaBallMultiplier: 5 | 10 | 25 | 50 | 100;
}
```

#### Visual Effects

- Golden glow on Mega Ball when drawn
- Multiplier reveal: dramatic zoom + screen shake
- Line completion: cards light up row/column/diagonal
- Drum interior lighting: subtle color cycling

---

### Dream Catcher / Money Wheel

Large vertical spinning wheel with flapper, inspired by TV game shows.

#### Gameplay

1. Bet on segment: 1, 2, 5, 10, 20, 40, or multiplier (2x, 7x)
2. Wheel spins; flapper indicates winning segment
3. Multiplier segments trigger re-spin with multiplied payouts

#### 3D Scene

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              DREAM CATCHER                       â”‚
â”‚                                                  â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚           â”‚      FLAPPER      â”‚                 â”‚
â”‚           â”‚         â–¼         â”‚                 â”‚
â”‚       â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”             â”‚
â”‚       â”‚    1   2   5   10   20    â”‚             â”‚
â”‚       â”‚  40   Ã—2   1   2   5      â”‚  â—„â”€ Wheel  â”‚
â”‚       â”‚    10  20  40  Ã—7  1      â”‚             â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                  â”‚
â”‚   Bet:  â—‹ 1   â—‹ 2   â—‹ 5   â—‹ 10   â—‹ 20   â—‹ 40   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Physics Model

```typescript
const MONEY_WHEEL_PHYSICS = {
  wheelRadius: 2.5, // meters
  segmentCount: 54,
  flapperPivotOffset: 2.6, // Above wheel center
  flapperLength: 0.3,
  flapperMass: 0.1,
  flapperRestitution: 0.3,
  wheelFriction: 0.02, // Very low for long spin
  wheelAngularDamping: 0.005, // Gradual slowdown
  pegHeight: 0.08, // Wheel pegs that hit flapper
};
```

**Flapper Simulation**:

- Flapper is a hinged rigid body that bounces off wheel pegs
- Each peg collision produces "tick" sound
- Flapper settles between two pegs at rest

**Guided Outcome**:

- Apply subtle torque to wheel during slow phase
- Target: winning segment aligned under flapper
- More aggressive deceleration than live wheel (Evolution's First Person Dream Catcher is faster)

#### Chain Integration

```typescript
interface DreamCatcherOutcome {
  segment: 1 | 2 | 5 | 10 | 20 | 40 | "2x" | "7x";
  // If multiplier, includes re-spin result
  multiplierChain?: DreamCatcherOutcome[];
}
```

#### Multiplier Handling

When 2x or 7x is hit:

1. Celebration effect (lights, sound)
2. All pending bets multiplied
3. Automatic re-spin
4. Recursive outcome resolution

#### Audio

- **Tick-tick-tick**: Each peg-flapper collision
- **Whoosh**: Fast spin wind sound (volume scales with speed)
- **Ding**: Final stop
- **Fanfare**: Multiplier hit

---

### Lightning Roulette (Separate Mode)

Enhanced roulette with random multipliers on 1-5 lucky numbers per round.

#### Gameplay

Standard roulette with added step:

1. Bets placed
2. Lightning strikes: 1-5 numbers randomly selected, each gets 50x-500x multiplier
3. Ball spins; straight-up bets on lucky numbers pay multiplied amount

#### Visual Treatment

Reuse `RouletteScene3D` with additions:

- Pre-spin: dramatic lightning strikes on betting grid
- Lucky number markers: electric arcs, bright glow
- If ball lands on lucky number: massive lightning explosion effect

#### Chain Integration

```typescript
interface LightningRouletteOutcome extends RouletteOutcome {
  luckyNumbers: Array<{
    number: number;
    multiplier: 50 | 100 | 200 | 300 | 400 | 500;
  }>;
}
```

#### Shader Enhancement

```glsl
// LightningRouletteGrid.frag
uniform int uLuckyNumbers[5];
uniform int uLuckyCount;
uniform float uMultipliers[5];
uniform float uStrikeProgress;  // 0-1 animation progress

void main() {
  // Highlight cells matching lucky numbers
  // Animate lightning arc using noise-based displacement
  // Scale brightness by multiplier value
}
```

---

### Crazy Time (Futureâ€”Complex)

Evolution's flagship game show: wheel + four bonus games. Extremely complex to replicate.

**Components**:

1. Main wheel (54 segments including 4 bonus triggers)
2. Coin Flip bonus (coin flip with multipliers)
3. Cash Hunt bonus (grid of multiplier icons)
4. Pachinko bonus (ball drop through pegs)
5. Crazy Time bonus (larger wheel)

**Implementation Complexity**: Very High. Recommend Phase 3+ after core games stable.

**Simplified Approach**:

- Implement main wheel only initially
- Bonus games as separate 2D mini-games
- Full 3D bonus games in future iteration

---

# DETAILED IMPLEMENTATION SPECIFICATIONS

The following sections provide production-ready specifications for each major system.

---

## A. Guided Physics System

### A.1 Core Types and Interfaces

```typescript
// guidedForces.ts

export interface AttractorConfig {
  /** Strength curve: 'linear' | 'quadratic' | 'inverse-square' */
  falloffCurve: "linear" | "quadratic" | "inverse-square";
  /** Base force strength in Newtons */
  baseStrength: number;
  /** Effective radius in world units (force = 0 beyond this) */
  effectiveRadius: number;
  /** Velocity threshold (m/s) - attractors only activate below this */
  velocityGate: number;
  /** Maximum force magnitude cap (prevents teleportation) */
  forceClamp: number;
  /** Noise modulation amplitude (0-1) */
  noiseAmplitude: number;
  /** Noise frequency (higher = faster variation) */
  noiseFrequency: number;
}

export interface GuidanceState {
  targetPosition: THREE.Vector3;
  targetRotation?: THREE.Quaternion;
  phase: "cruise" | "settle";
  heightGate?: number;
  noiseOffset: number;
}

// Preset configurations
export const ATTRACTOR_PRESETS: Record<string, AttractorConfig> = {
  DICE_SETTLE: {
    falloffCurve: "quadratic",
    baseStrength: 12.0,
    effectiveRadius: 0.8,
    velocityGate: 4.5,
    forceClamp: 18.0,
    noiseAmplitude: 0.15,
    noiseFrequency: 1.2,
  },
  ROULETTE_BALL: {
    falloffCurve: "inverse-square",
    baseStrength: 8.0,
    effectiveRadius: 0.5,
    velocityGate: 3.0,
    forceClamp: 12.0,
    noiseAmplitude: 0.22,
    noiseFrequency: 1.8,
  },
  CARD_SNAP: {
    falloffCurve: "linear",
    baseStrength: 6.0,
    effectiveRadius: 0.3,
    velocityGate: 2.0,
    forceClamp: 8.0,
    noiseAmplitude: 0.08,
    noiseFrequency: 0.8,
  },
};
```

### A.2 Attractor Force Algorithm

```typescript
export function calculateAttractorForce(
  currentPos: THREE.Vector3,
  currentVel: THREE.Vector3,
  guidance: GuidanceState,
  config: AttractorConfig,
  deltaTime: number,
  workVec: THREE.Vector3,
): THREE.Vector3 | null {
  // Gate checks
  if (guidance.phase !== "settle") return null;
  if (!evaluateVelocityGate(currentVel, config.velocityGate)) return null;
  if (!evaluateHeightGate(currentPos, guidance.heightGate)) return null;

  // Calculate direction to target
  workVec.copy(guidance.targetPosition).sub(currentPos);
  const distance = workVec.length();

  if (distance > config.effectiveRadius || distance < 0.001) return null;
  workVec.normalize();

  // Calculate falloff factor (0-1)
  const normalizedDist = distance / config.effectiveRadius;
  let falloff: number;
  switch (config.falloffCurve) {
    case "linear":
      falloff = 1 - normalizedDist;
      break;
    case "quadratic":
      falloff = 1 - normalizedDist * normalizedDist;
      break;
    case "inverse-square":
      const safeDist = Math.max(0.05, normalizedDist);
      falloff = Math.min(1, 1 / (safeDist * safeDist));
      break;
  }

  // Apply noise modulation
  const noiseValue = sampleNoise3D(
    currentPos.x,
    currentPos.y,
    currentPos.z + guidance.noiseOffset,
    config.noiseFrequency,
  );
  const noiseFactor = 1 + noiseValue * config.noiseAmplitude;

  // Calculate and clamp force
  let forceMag = Math.min(
    config.baseStrength * falloff * noiseFactor,
    config.forceClamp,
  );
  workVec.multiplyScalar(forceMag);

  return workVec;
}
```

### A.3 Roulette Physics Constants

```typescript
export const ROULETTE_GEOMETRY = {
  BOWL_RADIUS: 2.8,
  BOWL_DEPTH: 0.4,
  ROTOR_RADIUS: 2.4,
  DEFLECTOR_COUNT: 8,
  DEFLECTOR_HEIGHT: 0.15,
  FRET_HEIGHT: 0.09,
  BALL_RADIUS: 0.06,
  BALL_MASS: 0.02, // kg (realistic ivory ball)
  RIM_HEIGHT: 0.32, // Height gate threshold
};

export const ROULETTE_PHYSICS = {
  GRAVITY: -9.81,
  BALL_RESTITUTION: 0.85,
  BALL_FRICTION: 0.15,
  DEFLECTOR_RESTITUTION: 0.6,
  ROTOR_RESTITUTION: 0.3,
  BOWL_FRICTION: 0.25,
};
```

### A.4 Dice Physics Constants

```typescript
export const DICE_PHYSICAL_PROPERTIES = {
  MASS: 0.0045, // kg (4.5 grams for 16mm die)
  SIZE: 0.016, // meters (16mm standard)
  RESTITUTION: 0.3, // Energy retention on bounce
  STATIC_FRICTION: 0.25,
  DYNAMIC_FRICTION: 0.2,
  LINEAR_DAMPING: 0.45,
  ANGULAR_DAMPING: 0.5,
  MIN_THROW_VELOCITY: 2.5, // m/s
  MAX_THROW_VELOCITY: 8.0, // m/s
  TYPICAL_THROW_ANGULAR_VEL: 15, // rad/s
};
```

### A.5 Card Physics (Bezier Deal)

```typescript
export function calculateCardBezierPath(
  from: THREE.Vector3,
  to: THREE.Vector3,
  arcHeight: number,
  t: number, // 0-1 progress
): { position: THREE.Vector3; rotation: THREE.Euler } {
  // Control points for cubic Bezier
  const p0 = from;
  const p3 = to;
  const p1 = new THREE.Vector3().lerpVectors(p0, p3, 0.33);
  p1.y += arcHeight;
  const p2 = new THREE.Vector3().lerpVectors(p0, p3, 0.67);
  p2.y += arcHeight;

  // Cubic Bezier formula
  const t1 = 1 - t;
  const position = new THREE.Vector3(
    t1 * t1 * t1 * p0.x +
      3 * t1 * t1 * t * p1.x +
      3 * t1 * t * t * p2.x +
      t * t * t * p3.x,
    t1 * t1 * t1 * p0.y +
      3 * t1 * t1 * t * p1.y +
      3 * t1 * t * t * p2.y +
      t * t * t * p3.y,
    t1 * t1 * t1 * p0.z +
      3 * t1 * t1 * t * p1.z +
      3 * t1 * t * t * p2.z +
      t * t * t * p3.z,
  );

  // Pitch rotation during flight (peaks at midpoint)
  const pitchAmount = Math.sin(t * Math.PI) * (Math.PI / 4);
  const rotation = new THREE.Euler(pitchAmount, 0, 0);

  return { position, rotation };
}

export const CARD_DEAL_PRESETS = {
  DEALER_TO_PLAYER: { arcHeight: 0.6, duration: 0.45, spinRate: Math.PI * 1.5 },
  DEALER_TO_SELF: { arcHeight: 0.4, duration: 0.35, spinRate: Math.PI * 1.2 },
};
```

---

## B. Shader and Materials System

### B.1 Material Presets

```typescript
// MaterialConfig.ts

export const MATERIAL_PRESETS: Record<string, MaterialPreset> = {
  felt: {
    roughness: 0.95,
    metalness: 0.02,
    envMapIntensity: 0.15,
    color: "#0f3a2e",
  },
  chrome: {
    roughness: 0.08,
    metalness: 1.0,
    envMapIntensity: 1.2,
    color: "#b0b8c0",
  },
  polishedWood: {
    roughness: 0.35,
    metalness: 0.15,
    envMapIntensity: 0.6,
    color: "#4a2918",
    clearcoat: 0.5,
    clearcoatRoughness: 0.25,
  },
  cardFace: {
    roughness: 0.45,
    metalness: 0.1,
    envMapIntensity: 0.4,
  },
  cardBack: {
    roughness: 0.6,
    metalness: 0.05,
    envMapIntensity: 0.3,
  },
  chip: {
    roughness: 0.4,
    metalness: 0.2,
    envMapIntensity: 0.5,
  },
  dice: {
    roughness: 0.28,
    metalness: 0.18,
    envMapIntensity: 0.6,
  },
  gold: {
    roughness: 0.2,
    metalness: 0.9,
    envMapIntensity: 1.0,
    color: "#ffd700",
    emissive: "#ffaa00",
    emissiveIntensity: 0.15,
  },
};
```

### B.2 Lightning Shader (GLSL)

```glsl
// Fragment shader for lightning effect
uniform float uTime;
uniform bool uLightningActive;
uniform vec3 uLightningColor;
uniform float uIntensity;
varying vec2 vUv;

float fractalNoise(vec3 p, int octaves) {
  float value = 0.0;
  float amplitude = 0.5;
  float frequency = 1.0;
  for (int i = 0; i < 4; i++) {
    if (i >= octaves) break;
    value += amplitude * snoise(p * frequency);
    frequency *= 2.0;
    amplitude *= 0.5;
  }
  return value;
}

float lightningBolt(vec2 uv, float time) {
  float mainPath = fractalNoise(vec3(uv.x * 3.0, uv.y * 8.0, time * 0.8), 3);
  float branch1 = fractalNoise(vec3(uv.x * 5.0 + 10.0, uv.y * 12.0, time * 1.2), 2);
  float bolt = mainPath * 0.6 + branch1 * 0.4;
  float thickness = 0.05 + sin(time * 3.0) * 0.02;
  return smoothstep(thickness + 0.05, thickness, abs(bolt));
}

void main() {
  if (!uLightningActive) discard;

  float lightning = lightningBolt(vUv, uTime);
  float pulse = 0.7 + 0.3 * sin(uTime * 6.0);
  float intensity = lightning * pulse * uIntensity;

  // Core glow (>1.0 for bloom)
  vec3 coreColor = uLightningColor * intensity * 8.0;
  vec3 glowColor = uLightningColor * pow(intensity, 0.5) * 2.0;

  gl_FragColor = vec4(coreColor + glowColor, min(1.0, intensity * 1.5));
}
```

### B.3 Baccarat Squeeze Vertex Shader

```glsl
uniform float uBendStrength; // 0.0 to 1.0
uniform float uRevealThreshold;
varying vec2 vUv;
varying float vReveal;

void main() {
  vUv = uv;

  // Non-linear bend: quadratic falloff from pivot (bottom edge)
  float bendAmount = uv.y * uv.y;
  vec3 bendOffset = vec3(0.0);

  if (uBendStrength > 0.001) {
    float bendAngle = uBendStrength * bendAmount * 1.5708; // Max 90Â°
    float radius = 1.0 / (uBendStrength + 0.1);
    float arcLength = position.y;
    float x = sin(bendAngle * arcLength) * radius;
    float y = (1.0 - cos(bendAngle * arcLength)) * radius;
    bendOffset = vec3(0.0, y * uBendStrength, -x * uBendStrength * 0.5);
  }

  vReveal = smoothstep(uRevealThreshold - 0.1, uRevealThreshold + 0.1, bendAmount);
  vec3 transformed = position + bendOffset;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
}
```

### B.4 Post-Processing Pipeline

```typescript
// CasinoPostProcessing.tsx

export const CasinoPostProcessing: React.FC<Props> = ({
  enabled = true,
  bloomEnabled = true,
  bloomIntensity = 1.5,
  bloomThreshold = 1.0,
  toneMappingMode = ToneMappingMode.ACES_FILMIC,
}) => {
  if (!enabled) return <>{children}</>;

  return (
    <EffectComposer
      multisampling={0}
      frameBufferType={THREE.HalfFloatType}
    >
      {bloomEnabled && (
        <Bloom
          intensity={bloomIntensity}
          luminanceThreshold={bloomThreshold}
          luminanceSmoothing={0.9}
          height={300}
          blendFunction={BlendFunction.ADD}
        />
      )}
      <ToneMapping mode={toneMappingMode} />
    </EffectComposer>
  );
};
```

### B.5 Lighting Presets

```typescript
export type LightingPreset = "speakeasy" | "casino" | "vip" | "lightning";

// Speakeasy: warm amber (jazz club vibes)
// Casino: neon terminal aesthetic (#22ff88 green)
// VIP: luxurious gold accents
// Lightning: high-contrast cool blue for lightning effects
```

---

## C. Card System Architecture

### C.1 Card Pool Manager

```typescript
export class CardPoolManager {
  private readonly poolSize: number;
  private readonly geometry: THREE.BufferGeometry;
  private readonly atlasMaterial: THREE.MeshStandardMaterial;
  private readonly backMaterial: THREE.MeshStandardMaterial;
  private readonly pool: PooledCard[] = [];
  private readonly active = new Set<PooledCard>();

  checkout(card: Card | null): PooledCard {
    let pooledCard = this.pool.pop() ?? this.createCard();
    this.active.add(pooledCard);
    pooledCard.updateCard(card);
    return pooledCard;
  }

  return(pooledCard: PooledCard): void {
    this.active.delete(pooledCard);
    pooledCard.mesh.visible = false;
    pooledCard.mesh.position.set(0, 0, 0);
    this.pool.push(pooledCard);
  }

  dispose(): void {
    [...this.active, ...this.pool].forEach((card) => card.dispose());
    this.geometry.dispose();
    this.atlasMaterial.dispose();
    this.backMaterial.dispose();
  }
}
```

### C.2 Texture Atlas Specification

- **Layout**: 13 ranks Ã— 4 suits = 52 cards
- **Resolution**: 3328Ã—1424 pixels (256Ã—356 per card)
- **UV Calculation**:
  ```typescript
  col = RANKS.indexOf(rank); // 0-12
  row = SUITS.indexOf(suit); // 0-3
  repeat = new Vector2(1 / 13, 1 / 4);
  offset = new Vector2(col / 13, 1 - (row + 1) / 4);
  ```

### C.3 Deal Animation Stagger Timing

```typescript
export class StaggeredDealManager {
  constructor(configs: DealAnimationConfig[], staggerDelayMs: number = 130) {
    this.delays = configs.map((_, i) => i * staggerDelayMs);
    this.animators = configs.map((c) => new CardDealAnimator(c));
  }
}
```

### C.4 Dealer Peek Animation

```typescript
export class CardPeekAnimator {
  // 15-degree corner lift, 800ms total
  // Phases: lift (30%) â†’ hold (400ms) â†’ snap (20%)

  constructor(cardSize: [number, number, number]) {
    this.pivotPoint.set(cardSize[0] / 2, -cardSize[1] / 2, 0);
    this.liftDuration = 240; // 30% of 800ms
    this.holdEnd = 640; // lift + 400ms hold
    this.snapEnd = 800; // + 20% snap
  }
}
```

---

## D. State Management (GuidedStore)

### D.1 Core Types

```typescript
export type RoundPhase = "idle" | "launch" | "decay" | "settle" | "reveal";

export interface GuidedRound<TOutcome> {
  roundId: number;
  phase: RoundPhase;
  seed: number;
  startTime: number;
  phaseStartTime: number;
  launchImpulse?: Vector3;
  targetOutcome?: TOutcome;
  pendingOutcome?: TOutcome;
  actualOutcome?: TOutcome;
  minAnimationDuration: number;
  maxAnimationDuration: number;
  isAnimationBlocking: boolean;
  skipRequested: boolean;
}
```

### D.2 Game-Specific Outcomes

```typescript
// ============ CORE GAMES ============

export interface RouletteOutcome {
  number: number;
  color: "red" | "black" | "green";
}

export interface LightningRouletteOutcome extends RouletteOutcome {
  luckyNumbers: Array<{
    number: number;
    multiplier: 50 | 100 | 200 | 300 | 400 | 500;
  }>;
}

export interface CrapsOutcome {
  die1: number;
  die2: number;
  total: number;
}

export interface SicBoOutcome {
  dice: [number, number, number];
}

export interface BlackjackOutcome {
  card: { rank: string; suit: string };
  handType: "player" | "dealer";
}

export interface BaccaratOutcome {
  card: { rank: string; suit: string };
  handType: "player" | "banker";
}

export interface WarOutcome {
  playerCard: { rank: string; suit: string };
  dealerCard: { rank: string; suit: string };
  winner: "player" | "dealer" | "tie";
}

// ============ CARD GAME EXTENSIONS ============

export interface ThreeCardPokerOutcome {
  playerHand: [Card, Card, Card];
  dealerHand: [Card, Card, Card];
  playerHandRank: PokerHandRank;
  dealerHandRank: PokerHandRank;
  winner: "player" | "dealer" | "push";
  dealerQualifies: boolean;
  pairPlusWin?: { rank: PokerHandRank; payout: number };
}

export interface CasinoHoldemOutcome {
  playerHoleCards: [Card, Card];
  dealerHoleCards: [Card, Card];
  communityCards: [Card, Card, Card, Card, Card];
  playerBestHand: Card[];
  dealerBestHand: Card[];
  winner: "player" | "dealer" | "push";
  aaBonus?: { rank: string; payout: number };
}

export interface HiLoOutcome {
  currentCard: Card;
  nextCard: Card;
  comparison: "higher" | "lower" | "same";
  streakCount: number;
  multiplier: number;
}

export interface VideoPokerOutcome {
  initialHand: [Card, Card, Card, Card, Card];
  heldPositions: boolean[];
  finalHand: [Card, Card, Card, Card, Card];
  handRank: VideoPokerHand;
  payout: number;
}

// ============ GAME SHOWS ============

export interface FootballStudioOutcome {
  homeCard: Card;
  awayCard: Card;
  winner: "home" | "away" | "draw";
}

export interface MegaBallOutcome {
  drawnNumbers: number[]; // 20 numbers (1-51)
  megaBallNumber: number;
  megaBallMultiplier: 5 | 10 | 25 | 50 | 100;
}

export interface DreamCatcherOutcome {
  segment: 1 | 2 | 5 | 10 | 20 | 40 | "2x" | "7x";
  multiplierChain?: DreamCatcherOutcome[]; // Recursive for re-spins
}

// ============ HELPER TYPES ============

export interface Card {
  rank: string; // 'A', '2'-'10', 'J', 'Q', 'K'
  suit: string; // 'hearts', 'diamonds', 'clubs', 'spades'
}

export type PokerHandRank =
  | "high_card"
  | "pair"
  | "two_pair"
  | "three_of_a_kind"
  | "straight"
  | "flush"
  | "full_house"
  | "four_of_a_kind"
  | "straight_flush"
  | "royal_flush";

export type VideoPokerHand =
  | "royal_flush"
  | "straight_flush"
  | "four_of_a_kind"
  | "full_house"
  | "flush"
  | "straight"
  | "three_of_a_kind"
  | "two_pair"
  | "jacks_or_better"
  | "nothing";
```

### D.3 Transient Update Pattern

```typescript
// Subscribe directly in useFrame without React re-renders
export function subscribeToTransientUpdates(callback: () => void): () => void {
  const store = useGuidedStore.getState();
  store.transientSubscribers.add(callback);
  return () => store.transientSubscribers.delete(callback);
}
```

### D.4 Round ID Derivation (Chain-Based)

```typescript
// ALL outcomes come from chain state - NEVER calculate locally

// Roulette
const roundId = chainState.rouletteHistory.length;
const outcome = chainState.rouletteHistory[roundId - 1];

// Craps
const roundId = chainState.crapsRollHistory.length;
const outcome = {
  die1: chainState.dice[0],
  die2: chainState.dice[1],
  total: chainState.dice[0] + chainState.dice[1],
};

// Sic Bo
const roundId = chainState.sicBoHistory.length;
const outcome = { dice: chainState.dice.slice(0, 3) };

// Blackjack
const roundId = chainState.sessionId * 1000 + chainState.moveNumber;
const outcome = {
  playerCards: chainState.playerCards,
  dealerCards: chainState.dealerCards,
  stage: chainState.stage,
};

// Baccarat
const roundId = chainState.sessionId * 1000 + chainState.cardNumber;
const outcome = {
  playerCards: chainState.playerCards,
  bankerCards: chainState.bankerCards,
};
```

### D.5 Deterministic RNG (Mulberry32)

```typescript
export class SeededRandom {
  private state: number;

  constructor(seed: number) {
    this.state = seed >>> 0;
  }

  next(): number {
    let z = (this.state += 0x6d2b79f5);
    z = Math.imul(z ^ (z >>> 15), z | 1);
    z ^= z + Math.imul(z ^ (z >>> 7), z | 61);
    return ((z ^ (z >>> 14)) >>> 0) / 4294967296;
  }
}

export function generateRoundSeed(gameType: string, roundId: number): number {
  const gameHashes = {
    roulette: 0x1234,
    craps: 0x5678,
    sicbo: 0x9abc,
    blackjack: 0xdef0,
    baccarat: 0x1357,
    war: 0x2468,
  };
  return ((gameHashes[gameType] << 16) | (roundId & 0xffff)) >>> 0;
}
```

---

## E. Audio System

### E.1 AudioManager Singleton

```typescript
class AudioManager {
  private ctx: AudioContext | null = null;
  private masterGain: GainNode | null = null;
  private compressor: DynamicsCompressorNode | null = null;
  private reverb: ConvolverNode | null = null;

  static getInstance(): AudioManager;
  getContext(): AudioContext;
  getMasterGain(): GainNode;
  setVolume(volume: number): void;
  setMuted(muted: boolean): void;
  async unlock(): Promise<boolean>;
  setAmbienceProfile(profile: "speakeasy" | "vegas" | "vip" | "off"): void;
  dispose(): void;
}
```

### E.2 Procedural Sound Generation

```typescript
// Collision sounds
function createDiceImpact(
  ctx: AudioContext,
  params: { velocity: number; material: string },
): AudioNode;
function createBallBounce(
  ctx: AudioContext,
  velocity: number,
  surface: "metal" | "felt",
): AudioNode;
function createCardSnap(ctx: AudioContext): AudioNode;

// Continuous loops
function createRollingLoop(
  ctx: AudioContext,
  baseFreq: number,
): { source: AudioBufferSourceNode; gain: GainNode };
function createSpinningLoop(ctx: AudioContext): {
  source: AudioBufferSourceNode;
  gain: GainNode;
};

// Ambience
function createCrowdNoise(ctx: AudioContext, density: number): AudioNode;
```

### E.3 Collision Sound Component

```typescript
interface CollisionSoundProps {
  enabled?: boolean;
  material?: 'plastic' | 'metal' | 'felt' | 'rubber' | 'wood';
  velocityThreshold?: number;
  cooldownMs?: number;
  volume?: number;
}

// Usage:
<RigidBody onCollisionEnter={handleCollision}>
  <DiceModel />
  <CollisionSound material="plastic" cooldownMs={90} />
</RigidBody>
```

### E.4 Positional Audio Emitter

```typescript
interface PositionalAudioEmitterProps {
  soundType: "roll" | "spin" | "tumble";
  volume?: number;
  distanceModel?: "linear" | "inverse" | "exponential";
  refDistance?: number;
  maxDistance?: number;
  velocityRef?: React.MutableRefObject<THREE.Vector3>;
  pitchScale?: number;
}
```

### E.5 Ambient Soundscape Profiles

- **Speakeasy**: Intimate, quiet (density: 0.3)
- **Vegas**: Busy casino floor (density: 0.8)
- **VIP**: Minimal lounge (density: 0.15)

---

## F. File Structure Summary

```
website/src/components/casino/3d/
â”œâ”€â”€ engine/
â”‚   â”œâ”€â”€ GuidedStore.ts              # Zustand transient updates
â”‚   â”œâ”€â”€ GuidedRound.ts              # Round state types
â”‚   â””â”€â”€ timeStep.ts                 # Fixed timestep helpers
â”œâ”€â”€ physics/
â”‚   â”œâ”€â”€ guidedForces.ts             # Attractors, velocity gates
â”‚   â”œâ”€â”€ RoulettePhysics.ts          # Roulette-specific physics
â”‚   â”œâ”€â”€ CardPhysics.ts              # Bezier deal animations
â”‚   â””â”€â”€ noise.ts                    # Seeded Perlin/Simplex
â”œâ”€â”€ materials/
â”‚   â””â”€â”€ MaterialConfig.ts           # PBR material presets
â”œâ”€â”€ shaders/
â”‚   â”œâ”€â”€ LightningShader.ts          # Lightning effect GLSL
â”‚   â””â”€â”€ SqueezeShader.ts            # Baccarat squeeze GLSL
â”œâ”€â”€ effects/
â”‚   â”œâ”€â”€ CasinoPostProcessing.tsx    # Bloom + tone mapping
â”‚   â”œâ”€â”€ LightningEffect.tsx         # Lightning mesh component
â”‚   â””â”€â”€ SqueezeCard.tsx             # Squeezable card component
â”œâ”€â”€ environments/
â”‚   â”œâ”€â”€ LightingRig.tsx             # Preset-based lighting
â”‚   â””â”€â”€ EnvironmentManager.tsx      # HDR + tone mapping
â”œâ”€â”€ audio/
â”‚   â”œâ”€â”€ CollisionSound.tsx          # Physics collision audio
â”‚   â”œâ”€â”€ PositionalAudioEmitter.tsx  # Spatial audio
â”‚   â””â”€â”€ AmbientSoundscape.tsx       # Background ambience
â”œâ”€â”€ cards/
â”‚   â”œâ”€â”€ CardPoolManager.ts          # Object pool for cards
â”‚   â”œâ”€â”€ CardDealAnimation.ts        # Bezier deal system
â”‚   â””â”€â”€ CardPeekAnimation.ts        # Dealer peek animation
â””â”€â”€ scenes/
    â”œâ”€â”€ roulette/
    â”œâ”€â”€ craps/
    â”œâ”€â”€ sicbo/
    â”œâ”€â”€ blackjack/
    â”œâ”€â”€ baccarat/
    â””â”€â”€ war/
```

---

## G. Build Sequence (Detailed)

### Phase 1: Core Infrastructure (Days 1-2)

1. Install dependencies: `simplex-noise`, `@react-three/postprocessing`
2. Create `GuidedStore.ts` with all game slices
3. Create `guidedForces.ts` with attractor algorithm
4. Create `deterministicRng.ts` with Mulberry32 PRNG
5. Create `MaterialConfig.ts` with all presets
6. Unit test attractor force calculations

### Phase 2: Roulette + Dice Physics (Days 3-4)

1. Implement `RoulettePhysics.ts` (launch, pocket calculation)
2. Add collider setup for bowl, rotor, deflectors, frets
3. Integrate guided settling with attractor forces
4. Add mechanical arm release physics for Craps/Sic Bo
5. Add pyramid collider mesh to back walls

### Phase 3: Card System (Days 5-6)

1. Create `CardPoolManager.ts` with checkout/return API
2. Implement `CardDealAnimation.ts` with Bezier curves
3. Create `CardPeekAnimation.ts` for dealer peek
4. Integrate with existing card components

### Phase 4: Shaders + Post-Processing (Days 7-8)

1. Create `LightningShader.ts` with GLSL code
2. Create `SqueezeShader.ts` for Baccarat
3. Create `CasinoPostProcessing.tsx` wrapper
4. Create `LightingRig.tsx` with all presets
5. Test bloom with emissive materials

### Phase 5: Audio System (Days 9-10)

1. Create `AudioManager.ts` singleton
2. Create `proceduralSounds.ts` library
3. Create `CollisionSound.tsx` component
4. Create `PositionalAudioEmitter.tsx`
5. Create `AmbientSoundscape.tsx`
6. Test iOS audio unlock flow

### Phase 6: Integration + Polish (Days 11-12)

1. Wire chain events to store actions
2. Update all 3D scenes to use new systems
3. Add animation blocking coordination
4. Performance profiling (60 FPS target)
5. Mobile optimization pass

---

## H. Performance Targets

- **Frame Rate**: 60 FPS on desktop, 30+ FPS on mobile
- **Physics Step**: Fixed 1/60s timestep
- **GC Pauses**: < 1ms (use transient updates, pre-allocated vectors)
- **Texture Memory**: ~10MB (atlas + environment maps)
- **Audio Latency**: < 20ms (procedural generation, no asset loading)
- **First Paint**: < 2s (lazy load non-critical assets)

---

## I. Evolution Feature Comparison Matrix

### Core Features

| Feature               | Evolution First Person   | Our Implementation | Notes                        |
| --------------------- | ------------------------ | ------------------ | ---------------------------- |
| Physics Engine        | Proprietary              | Rapier.js          | Deterministic, WASM-based    |
| RNG Source            | Server-side              | Blockchain         | Provably fair advantage      |
| Easy Mode             | âœ… (Craps)               | âœ…                 | Simplified betting UI        |
| My Numbers            | âœ… (Craps)               | âœ…                 | Personalized payout display  |
| Mechanical Arm        | âœ… (Craps)               | âœ…                 | Animated dice shooter        |
| Squeeze Cards         | âœ… (Baccarat)            | âœ…                 | Interactive card reveal      |
| Shuffle on Demand     | âœ… (Baccarat)            | âœ…                 | Player-controlled shoe reset |
| Free Hands            | âœ… (Baccarat)            | âœ…                 | Trend building               |
| Multi-Table           | âœ… (Baccarat, 12 tables) | Phase 2            | Requires chain support       |
| Go Live Portal        | âœ…                       | Future             | Transition to live dealer    |
| Dynamic Lighting      | âœ… (Dragon Tiger)        | âœ…                 | Outcome-driven color shifts  |
| Fast Play             | âœ…                       | âœ…                 | Deal Now, skip animations    |
| Tutorial Mode         | âœ…                       | âœ…                 | Tooltips, guided play        |
| Roadmaps              | âœ… (Baccarat)            | âœ…                 | Big Road, Bead Plate         |
| Lightning Multipliers | âœ… (Lightning Roulette)  | Phase 2            | Requires chain schema        |
| 3D Chip Stacks        | âœ…                       | âœ…                 | Realistic bet visualization  |
| Side Bet Spots        | âœ… (Blackjack)           | âœ…                 | Perfect Pairs, 21+3          |
| Table Sorting         | âœ… (Baccarat)            | âœ…                 | Sort by streak/pattern       |

### Game Coverage

| Game                   | Evolution | Our Plan | Phase  | Complexity |
| ---------------------- | --------- | -------- | ------ | ---------- |
| Roulette               | âœ…        | âœ…       | 1      | Medium     |
| Lightning Roulette     | âœ…        | âœ…       | 2      | Medium     |
| Craps                  | âœ…        | âœ…       | 1      | High       |
| Blackjack              | âœ…        | âœ…       | 1      | Low        |
| Baccarat               | âœ…        | âœ…       | 1      | Medium     |
| Dragon Tiger           | âœ…        | âœ…       | 1      | Low        |
| Sic Bo                 | âœ…        | âœ…       | 1      | Medium     |
| Three Card Poker       | âœ…        | âœ…       | 2      | Low        |
| Casino Hold'em         | âœ…        | âœ…       | 2      | Medium     |
| Ultimate Texas Hold'em | âœ…        | âœ…       | 2      | Medium     |
| HiLo                   | âœ…        | âœ…       | 2      | Low        |
| Video Poker            | âŒ        | âœ…       | 2      | Low        |
| Football Studio        | âœ…        | âœ…       | 3      | Low        |
| Mega Ball              | âœ…        | âœ…       | 3      | Very High  |
| Dream Catcher          | âœ…        | âœ…       | 3      | High       |
| Crazy Time             | âœ…        | Phase 4  | Future | Extreme    |

### Complexity Legend

- **Low**: Card dealing only, no physics
- **Medium**: Single physics object (ball, dice pair)
- **High**: Multiple physics objects or complex mechanics
- **Very High**: Many physics objects (51 balls) or complex bonus systems
- **Extreme**: Multiple interconnected sub-games

---

## J. Key Differentiators vs Evolution

While we replicate Evolution's quality, our platform offers unique advantages:

1. **Provable Fairness**: Blockchain-verified outcomes that players can audit
2. **Instant Settlement**: On-chain transactions without withdrawal delays
3. **Decentralized**: No single point of failure or censorship
4. **Transparent RNG**: Seed derivation from chain state is fully auditable
5. **Open Protocol**: Other clients can build on the same chain data

### Addressing Player Trust Concerns ("Is it rigged?")

Players often speculate that digital games are "rigged" or use hidden "magnets" to control outcomes. Evolution's mechanical shooter arm in Craps was designed specifically to address this:

> "The shooter arm... adds trust and visual continuity. Players intuitively trust a mechanical throw (even in digital form) more than just seeing dice magically appear rolling."

**Our Trust-Building Approach**:

1. **Visible Mechanical Elements**: The robotic arm in Craps provides a physical-looking cause for dice motion
2. **Blockchain Verification**: Players can verify any outcome against on-chain data
3. **Deterministic Replay**: Same seed always produces identical animation (auditable)
4. **No Hidden Guidance During Chaos**: Attractor forces only activate when objects are nearly at rest

**Communication Strategy**:

- Show "Verify on Chain" button after each round
- Display seed/hash in advanced UI mode
- Emphasize that physics looks random because the _launch_ is randomâ€”only the _final position_ is predetermined (by provably fair RNG)
